# Skip blocks

Skip blocks are a special type of [micro block](/learn/protocol/block-format.md#micro-blocks) in the consensus protocol. When a validator fails to produce a block within the expected timeframe, the remaining elected validators can collectively agree to add a skip block instead of the missing micro block. This prevents delays and ensures the blockchain progresses smoothly. Once a supermajority of elected validators agrees to add the skip block, the chain resumes its regular progression.

The primary purpose of skip blocks is to ensure blockchain continuity by serving a structural role rather than a transactional one. Unlike micro blocks, which process transactions, skip blocks are like placeholders that prevent interruptions when a validator fails to produce a block.

Skip blocks are canonical, meaning their structure is strictly determined by the protocol. For any given block, the skip block that follows is determined by the protocol rules. Once a skip block is added, the chain resumes regular micro block production with one validator per block. There is no maximum limit on the number of skip blocks, as skip blocks adapt to the chain’s continuity.

### Skip Block and Micro Block Differences

Skip blocks are a special type of micro block, but because they don’t hold transactions, there are some key differences. Below are the main differences between a skip block and a regular micro block:

| **Feature** | **Skip Block** | **Micro Block** |
| --- | --- | --- |
| **Body** | Empty – skip blocks have no transactions or equivocation proof data | Contains transaction data and possibly equivocation proofs |
| **Body Root** | The `body_root` field in the block header is the hash of the empty body | The `body_root` is the hash of the body, which includes the transactions and equivocation proofs |
| **Timestamp** | Derived from the previous block’s timestamp plus a fixed duration (4 seconds) | Generated based on the block’s production time by the assigned producer |
| **Extra Data** | Must be empty to ensure the skip block is canonical | Can include additional data as required by the transactions or block producer |
| **VRF Seed** | Inherits the VRF from the previous micro block without introducing new randomness | A new VRF seed is generated by the block producer introducing new randomness |
| **Justification** | Aggregated signatures from multiple validators | Single signature from the assigned producer |
| **Producer** | No specific producer; multiple validators attest to the skip block | Block producer selected to produce the block |

<img class="object-contain max-h-[max(80vh,220px)]" src="/assets/images/protocol/skip-micro.png" alt="skip block comparison to micro blocks" />

### How is the Skip Block Added?

A skip block is an agreement among validators to confirm they did not see a micro block in the expected timeframe. The block’s justification consists of the aggregated signatures from the validators. The process goes as follows:

1. The elected validator fails to produce a micro block within the expected timeframe
2. Upon noticing the missing block, any validator can create a skip block locally
3. Validators each create and sign their skip block, then share their signatures with peers
4. When at least 2*f*+1 signatures are collected, they are aggregated into the skip block proof
5. The skip block is added and the chain resumes regular block production with the next validator. If the next validator fails, the process above repeats

**There are only two outcomes for a delayed micro block:**

- Receive 2*f*+1 signatures to a skip block, add it to the chain, and resume the block production
- Wait to receive a micro block; if a validator doesn’t receive a skip block, it means that at least 2*f*+1 validators saw the expected micro block, and the remainder should receive it shortly

### Validator Penalty for Misbehavior

A delay in the block production is considered a minor offense. When a validator fails to produce a micro block in time, the associated slot is marked to not receive rewards, which are burned as a penalty. This delay also results in the deactivation of the validator slot, although it can reactivate itself after one block. For more information on this misbehavior, see the [punishments document](/learn/protocol/punishments.md#block-production-delay).
